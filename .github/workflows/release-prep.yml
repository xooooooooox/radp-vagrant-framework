name: Release prep

on:
  workflow_dispatch:
    inputs:
      bump_type:
        description: "Release version bump type"
        type: choice
        options:
          - patch
          - minor
          - major
          - manual
        default: patch
        required: true
      version:
        description: "Manual release version tag (vX.Y.Z) when bump_type=manual"
        required: false

permissions:
  contents: write
  pull-requests: write

jobs:
  release-prep:
    if: github.ref == 'refs/heads/main'
    runs-on: ubuntu-latest
    defaults:
      run:
        shell: bash
    steps:
      - name: Checkout
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Fetch tags
        run: git fetch --tags --force

      - name: Resolve version
        id: version
        run: |
          set -euo pipefail
          bump_type="${{ inputs.bump_type }}"
          manual_version="${{ inputs.version }}"

          # Get latest version tag from git
          latest_tag="$(git tag --list 'v*' --sort=-v:refname | head -n 1)"

          # Handle initial release (no tags)
          if [[ -z "${latest_tag}" ]]; then
            echo "No version tags found; using v0.0.0 as base for initial release."
            latest_tag="v0.0.0"
          fi

          if [[ ! "${latest_tag}" =~ ^v([0-9]+)\.([0-9]+)\.([0-9]+)$ ]]; then
            echo "Latest tag '${latest_tag}' does not match vX.Y.Z" >&2
            exit 1
          fi
          major="${BASH_REMATCH[1]}"
          minor="${BASH_REMATCH[2]}"
          patch="${BASH_REMATCH[3]}"

          case "${bump_type}" in
            patch)
              version="v${major}.${minor}.$((patch + 1))"
              ;;
            minor)
              version="v${major}.$((minor + 1)).0"
              ;;
            major)
              version="v$((major + 1)).0.0"
              ;;
            manual)
              if [[ -z "${manual_version}" ]]; then
                echo "Manual bump_type requires inputs.version." >&2
                exit 1
              fi
              version="${manual_version}"
              ;;
            *)
              echo "Unsupported bump_type: ${bump_type}" >&2
              exit 1
              ;;
          esac

          if [[ ! "${version}" =~ ^v[0-9]+\.[0-9]+\.[0-9]+$ ]]; then
            echo "Version '${version}' does not match vX.Y.Z" >&2
            exit 1
          fi

          echo "version=${version}" >> "$GITHUB_OUTPUT"
          echo "latest=${latest_tag}" >> "$GITHUB_OUTPUT"

      - name: Create release branch
        id: branch
        run: |
          set -euo pipefail
          version="${{ steps.version.outputs.version }}"
          if git rev-parse "${version}" >/dev/null 2>&1; then
            echo "Tag ${version} already exists. Aborting release prep." >&2
            exit 1
          fi
          branch="workflow/${version}"
          reused=false
          if git ls-remote --exit-code --heads origin "${branch}" >/dev/null 2>&1; then
            git checkout -b "${branch}" "origin/${branch}"
            echo "Reusing existing branch ${branch}"
            reused=true
          else
            git checkout -b "${branch}"
          fi
          echo "branch=${branch}" >> "$GITHUB_OUTPUT"
          echo "reused=${reused}" >> "$GITHUB_OUTPUT"

      - name: Update versions and changelog
        env:
          VERSION: ${{ steps.version.outputs.version }}
        run: |
          set -euo pipefail
          python3 - <<'PY'
          import os
          import re
          import subprocess
          from pathlib import Path

          version = os.environ["VERSION"].strip()
          if not re.match(r"^v[0-9]+\.[0-9]+\.[0-9]+$", version):
            raise SystemExit(f"Invalid version: {version}")

          def git(*args: str) -> str:
            return subprocess.check_output(["git", *args], text=True, errors="replace").strip()

          def try_git(*args: str) -> str:
            try:
              return git(*args)
            except subprocess.CalledProcessError:
              return ""

          # Update version.rb
          version_path = Path("src/main/ruby/lib/radp_vagrant/version.rb")
          if not version_path.exists():
            raise SystemExit(f"Missing version file: {version_path}")
          version_text = version_path.read_text()
          version_text, count = re.subn(
            r"^\s*VERSION\s*=\s*['\"].*['\"]",
            f"  VERSION = '{version}'",
            version_text,
            flags=re.M,
          )
          if count == 0:
            raise SystemExit("Failed to update VERSION in version.rb")
          version_path.write_text(version_text)

          # Update version.sh (keep in sync with Ruby for --config and banner)
          version_sh_path = Path("src/main/shell/commands/version.sh")
          if version_sh_path.exists():
            version_sh_text = version_sh_path.read_text()
            version_sh_text, count = re.subn(
              r'^declare -gr gr_app_version="[^"]*"',
              f'declare -gr gr_app_version="{version}"',
              version_sh_text,
              flags=re.M,
            )
            if count > 0:
              version_sh_path.write_text(version_sh_text)
              print(f"Updated version.sh to {version}")

          # Update spec files
          version_no_prefix = version[1:]
          for spec_path in [
            Path("packaging/copr/radp-vagrant-framework.spec"),
            Path("packaging/obs/radp-vagrant-framework.spec"),
          ]:
            if not spec_path.exists():
              raise SystemExit(f"Missing spec file: {spec_path}")
            spec_text = spec_path.read_text()
            spec_text, count = re.subn(
              r"^Version:\s*.*$",
              f"Version:        {version_no_prefix}",
              spec_text,
              flags=re.M,
            )
            if count == 0:
              raise SystemExit(f"Failed to update Version in {spec_path}")
            spec_path.write_text(spec_text)
            print(f"Updated {spec_path} to {version_no_prefix}")

          # Update CHANGELOG.md
          changelog_path = Path("CHANGELOG.md")
          version_no_prefix = version[1:]

          if not changelog_path.exists():
            raise SystemExit("CHANGELOG.md not found.")
          changelog_text = changelog_path.read_text()
          header_pattern = re.compile(rf"^##\s+v?{re.escape(version_no_prefix)}(\s|$)")

          last_tag = try_git("describe", "--tags", "--abbrev=0", "--match", "v*")
          log_range = f"{last_tag}..HEAD" if last_tag else "HEAD"
          log_output = try_git("log", "--no-merges", "--pretty=%h %s", log_range)

          # Group commits by conventional commit type
          base_types = ["feat", "fix", "chore"]
          standard_types = base_types + ["docs", "refactor", "perf", "test", "build", "ci"]
          other_key = "other"
          entries_by_type = {t: [] for t in standard_types}
          entries_by_type[other_key] = []
          type_pattern = re.compile(r"^(?P<type>[A-Za-z][A-Za-z0-9_-]*)(\([^\)]*\))?:\s+(?P<desc>.+)$")

          for line in log_output.splitlines():
            line = line.strip()
            if not line:
              continue
            parts = line.split(" ", 1)
            sha = parts[0]
            subject = parts[1] if len(parts) > 1 else ""
            subject_ascii = subject.encode("ascii", "ignore").decode("ascii").strip()
            if not subject_ascii:
              subject_ascii = "<non-ascii subject>"
            match = type_pattern.match(subject_ascii)
            if match:
              commit_type = match.group("type").lower()
              desc = match.group("desc").strip() or subject_ascii
            else:
              commit_type = other_key
              desc = subject_ascii
            if commit_type not in entries_by_type:
              commit_type = other_key
            entries_by_type[commit_type].append(desc)

          default_header = f"## {version}"
          include_types = [t for t in standard_types if entries_by_type[t]]
          if entries_by_type[other_key]:
            include_types.append(other_key)

          def build_section_lines(header_line: str, leading_blank: bool) -> list[str]:
            section = []
            if leading_blank:
              section.append("")
            section.append(header_line)
            section.append("")
            if not include_types:
              section.append("- TODO: no commits found; add summary manually.")
              return section
            for commit_type in include_types:
              section.append(f"### {commit_type}")
              section.append("")
              for entry in entries_by_type.get(commit_type, []):
                section.append(f"- {entry}")
              section.append("")
            while section and section[-1] == "":
              section.pop()
            return section

          lines = changelog_text.splitlines()
          start = None
          for idx, line in enumerate(lines):
            if header_pattern.match(line):
              start = idx
              break
          if start is not None:
            end = len(lines)
            for idx in range(start + 1, len(lines)):
              if lines[idx].startswith("## "):
                end = idx
                break
            existing_section = "\n".join(lines[start:end])
            todo_markers = (
              "TODO: curate and rewrite this list before release.",
              "TODO: no commits found; add summary manually.",
            )
            if any(marker in existing_section for marker in todo_markers):
              header_line = lines[start]
              new_lines = build_section_lines(header_line, leading_blank=False)
              lines = lines[:start] + new_lines + lines[end:]
            else:
              print("CHANGELOG entry exists and appears edited; leaving it unchanged.")
          else:
            insert_at = 1 if lines and lines[0].strip() == "# CHANGELOG" else 0
            new_lines = build_section_lines(default_header, leading_blank=True)
            lines = lines[:insert_at] + new_lines + lines[insert_at:]

          changelog_path.write_text("\n".join(lines).rstrip() + "\n")
          print(f"Updated version to {version} (last tag: {last_tag or 'none'})")
          PY

      - name: Install radp-bash-framework
        run: |
          set -euo pipefail
          curl -fsSL https://raw.githubusercontent.com/xooooooooox/radp-bash-framework/main/install.sh | bash
          echo "$HOME/.local/bin" >> "$GITHUB_PATH"

      - name: Regenerate completion scripts
        run: |
          set -euo pipefail
          ./bin/radp-vf completion bash > completions/radp-vf.bash
          ./bin/radp-vf completion zsh > completions/radp-vf.zsh
          echo "Completion scripts regenerated"

      - name: Commit changes
        run: |
          set -euo pipefail
          if git diff --quiet; then
            if [[ "${{ steps.branch.outputs.reused }}" == "true" ]]; then
              echo "No changes to commit; branch already exists."
              exit 0
            fi
            echo "No changes to commit; aborting release prep." >&2
            exit 1
          fi
          git config user.name "github-actions[bot]"
          git config user.email "github-actions[bot]@users.noreply.github.com"
          git add \
            src/main/ruby/lib/radp_vagrant/version.rb \
            src/main/shell/commands/version.sh \
            packaging/copr/radp-vagrant-framework.spec \
            packaging/obs/radp-vagrant-framework.spec \
            completions/radp-vf.bash \
            completions/radp-vf.zsh \
            CHANGELOG.md
          git commit -m "Release prep ${{ steps.version.outputs.version }}"

      - name: Push branch
        run: |
          git push --set-upstream origin "${{ steps.branch.outputs.branch }}"

      - name: Create pull request
        env:
          GH_TOKEN: ${{ secrets.RELEASE_PREP_TOKEN || github.token }}
          HAS_RELEASE_PREP_TOKEN: ${{ secrets.RELEASE_PREP_TOKEN != '' }}
        run: |
          set -euo pipefail
          version="${{ steps.version.outputs.version }}"
          branch="${{ steps.branch.outputs.branch }}"
          title="Release ${version}"
          body_file="$(mktemp)"
          cat > "${body_file}" <<EOF
          Release prep for ${version}.

          - Update VERSION in version.rb
          - Update gr_app_version in version.sh
          - Sync spec versions
          - Regenerate completion scripts
          - Add changelog entry (please review and edit)

          When this PR is merged, create-version-tag will run automatically to validate and tag the release.
          EOF

          if gh pr create --base main --head "${branch}" --title "${title}" --body-file "${body_file}"; then
            exit 0
          fi
          if gh pr view --head "${branch}" >/dev/null 2>&1; then
            echo "PR already exists for ${branch}."
            exit 0
          fi
          if [[ "${HAS_RELEASE_PREP_TOKEN}" == "true" ]]; then
            echo "PR creation failed even with RELEASE_PREP_TOKEN; check token scopes and repo settings." >&2
            exit 1
          fi
          echo "PR creation not permitted for GitHub Actions token." >&2
          echo "Enable 'Allow GitHub Actions to create and approve pull requests' or create the PR manually:" >&2
          echo "  gh pr create --base main --head \"${branch}\" --title \"${title}\"" >&2
