name: Release prep

on:
  workflow_dispatch:
    inputs:
      bump_type:
        description: "Release version bump type"
        type: choice
        options:
          - patch
          - minor
          - major
          - manual
        default: patch
        required: true
      version:
        description: "Manual release version tag (vX.Y.Z) when bump_type=manual"
        required: false

permissions:
  contents: write
  pull-requests: write

jobs:
  release-prep:
    if: github.ref == 'refs/heads/main'
    runs-on: ubuntu-latest
    defaults:
      run:
        shell: bash
    steps:
      - name: Checkout
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Fetch tags
        run: git fetch --tags --force

      - name: Resolve version
        id: version
        run: |
          set -euo pipefail
          bump_type="${{ inputs.bump_type }}"
          manual_version="${{ inputs.version }}"
          latest_tag="$(git tag --list 'v*' --sort=-v:refname | head -n 1)"
          
          # If no tags exist, start from v0.0.0
          if [[ -z "${latest_tag}" ]]; then
            latest_tag="v0.0.0"
          fi
          
          if [[ ! "${latest_tag}" =~ ^v([0-9]+)\.([0-9]+)\.([0-9]+)$ ]]; then
            echo "Latest tag '${latest_tag}' does not match vX.Y.Z" >&2
            exit 1
          fi
          major="${BASH_REMATCH[1]}"
          minor="${BASH_REMATCH[2]}"
          patch="${BASH_REMATCH[3]}"

          case "${bump_type}" in
            patch)
              version="v${major}.${minor}.$((patch + 1))"
              ;;
            minor)
              version="v${major}.$((minor + 1)).0"
              ;;
            major)
              version="v$((major + 1)).0.0"
              ;;
            manual)
              if [[ -z "${manual_version}" ]]; then
                echo "Manual bump_type requires inputs.version." >&2
                exit 1
              fi
              version="${manual_version}"
              ;;
            *)
              echo "Unsupported bump_type: ${bump_type}" >&2
              exit 1
              ;;
          esac

          if [[ ! "${version}" =~ ^v[0-9]+\.[0-9]+\.[0-9]+$ ]]; then
            echo "Version '${version}' does not match vX.Y.Z" >&2
            exit 1
          fi

          echo "version=${version}" >> "$GITHUB_OUTPUT"
          echo "latest=${latest_tag}" >> "$GITHUB_OUTPUT"

      - name: Create release branch
        id: branch
        run: |
          set -euo pipefail
          version="${{ steps.version.outputs.version }}"
          if git rev-parse "${version}" >/dev/null 2>&1; then
            echo "Tag ${version} already exists. Aborting release prep." >&2
            exit 1
          fi
          branch="workflow/${version}"
          reused=false
          if git ls-remote --exit-code --heads origin "${branch}" >/dev/null 2>&1; then
            git checkout -b "${branch}" "origin/${branch}"
            echo "Reusing existing branch ${branch}"
            reused=true
          else
            git checkout -b "${branch}"
          fi
          echo "branch=${branch}" >> "$GITHUB_OUTPUT"
          echo "reused=${reused}" >> "$GITHUB_OUTPUT"

      - name: Update versions and changelog
        env:
          VERSION: ${{ steps.version.outputs.version }}
        run: |
          set -euo pipefail
          python3 - <<'PY'
          import os
          import re
          import subprocess
          from pathlib import Path

          version = os.environ["VERSION"].strip()
          if not re.match(r"^v[0-9]+\.[0-9]+\.[0-9]+$", version):
            raise SystemExit(f"Invalid version: {version}")

          def git(*args: str) -> str:
            return subprocess.check_output(["git", *args], text=True, errors="replace").strip()

          def try_git(*args: str) -> str:
            try:
              return git(*args)
            except subprocess.CalledProcessError:
              return ""

          # Update version.rb
          version_path = Path("src/main/ruby/lib/radp_vagrant/version.rb")
          if not version_path.exists():
            raise SystemExit(f"Missing version file: {version_path}")
          version_text = version_path.read_text()
          version_text, count = re.subn(
            r"^\s*VERSION\s*=\s*['\"].*['\"]",
            f"  VERSION = '{version}'",
            version_text,
            flags=re.M,
          )
          if count == 0:
            raise SystemExit("Failed to update VERSION in version.rb")
          version_path.write_text(version_text)

          # Update CHANGELOG.md
          changelog_path = Path("CHANGELOG.md")
          version_no_prefix = version[1:]
          
          last_tag = try_git("describe", "--tags", "--abbrev=0", "--match", "v*")
          log_range = f"{last_tag}..HEAD" if last_tag else "HEAD"
          log_output = try_git("log", "--no-merges", "--pretty=%h %s", log_range)
          
          # Build changelog entry
          entry_lines = [f"## {version}", ""]
          if log_output.strip():
            for line in log_output.strip().splitlines():
              # Remove commit hash prefix (first word)
              parts = line.split(" ", 1)
              desc = parts[1] if len(parts) > 1 else parts[0]
              entry_lines.append(f"- {desc}")
          else:
            entry_lines.append("- Initial release")
          entry_lines.append("")
          
          if changelog_path.exists():
            old_content = changelog_path.read_text()
            # Insert after first line if it's a header
            lines = old_content.splitlines()
            if lines and lines[0].startswith("# "):
              new_content = lines[0] + "\n\n" + "\n".join(entry_lines) + "\n".join(lines[1:])
            else:
              new_content = "\n".join(entry_lines) + old_content
          else:
            new_content = "# CHANGELOG\n\n" + "\n".join(entry_lines)
          
          changelog_path.write_text(new_content)
          print(f"Updated version to {version}")
          PY

      - name: Regenerate completion scripts
        run: |
          set -euo pipefail
          ./bin/radp-vf completion bash > completions/radp-vf.bash
          ./bin/radp-vf completion zsh > completions/radp-vf.zsh
          echo "Completion scripts regenerated"

      - name: Commit changes
        run: |
          set -euo pipefail
          if git diff --quiet; then
            if [[ "${{ steps.branch.outputs.reused }}" == "true" ]]; then
              echo "No changes to commit; branch already exists."
              exit 0
            fi
            echo "No changes to commit; aborting release prep." >&2
            exit 1
          fi
          git config user.name "github-actions[bot]"
          git config user.email "github-actions[bot]@users.noreply.github.com"
          git add \
            src/main/ruby/lib/radp_vagrant/version.rb \
            completions/radp-vf.bash \
            completions/radp-vf.zsh \
            CHANGELOG.md
          git commit -m "Release prep ${{ steps.version.outputs.version }}"

      - name: Push branch
        run: |
          git push --set-upstream origin "${{ steps.branch.outputs.branch }}"

      - name: Create pull request
        env:
          GH_TOKEN: ${{ secrets.RELEASE_PREP_TOKEN }}
          GITHUB_TOKEN: ${{ github.token }}
        run: |
          set -euo pipefail
          version="${{ steps.version.outputs.version }}"
          branch="${{ steps.branch.outputs.branch }}"
          title="Release ${version}"
          body="Release prep for ${version}. When merged, create-version-tag will run automatically."

          # Use RELEASE_PREP_TOKEN if set, otherwise fall back to GITHUB_TOKEN
          if [[ -z "${GH_TOKEN}" ]]; then
            export GH_TOKEN="${GITHUB_TOKEN}"
          fi

          if gh pr create --base main --head "${branch}" --title "${title}" --body "${body}"; then
            exit 0
          fi
          if gh pr view --head "${branch}" >/dev/null 2>&1; then
            echo "PR already exists for ${branch}."
            exit 0
          fi
          echo "PR creation failed. Create manually:" >&2
          echo "  gh pr create --base main --head \"${branch}\" --title \"${title}\"" >&2
