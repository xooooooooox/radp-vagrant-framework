#!/usr/bin/env bash
# RADP Vagrant Framework CLI
# https://github.com/xooooooooox/radp-vagrant-framework

set -euo pipefail

# Resolve script directory (handle symlinks)
resolve_script_dir() {
  local source="${BASH_SOURCE[0]}"
  while [[ -L "${source}" ]]; do
    local dir
    dir="$(cd -P "$(dirname "${source}")" && pwd)"
    source="$(readlink "${source}")"
    [[ "${source}" != /* ]] && source="${dir}/${source}"
  done
  cd -P "$(dirname "${source}")" && pwd
}

SCRIPT_DIR="$(resolve_script_dir)"

# Determine RADP_VF_HOME and RUBY_LIB_DIR
# Priority: env var > auto-detect from script location
#
# Two installation modes:
# 1. Development (git clone): bin/radp-vf in project root
#    - RADP_VF_HOME = project_root
#    - RUBY_LIB_DIR = project_root/src/main/ruby
#
# 2. Homebrew/installed: libexec/bin/radp-vf
#    - RADP_VF_HOME = libexec (contains Vagrantfile, lib/ directly)
#    - RUBY_LIB_DIR = libexec (same as RADP_VF_HOME)

if [[ -z "${RADP_VF_HOME:-}" ]]; then
  # Case 1: Development mode - project_root/bin/radp-vf
  if [[ -d "${SCRIPT_DIR}/../src/main/ruby/lib/radp_vagrant" ]]; then
    RADP_VF_HOME="$(cd "${SCRIPT_DIR}/.." && pwd)"
    RUBY_LIB_DIR="${RADP_VF_HOME}/src/main/ruby"
  # Case 2: Homebrew/installed mode - libexec/bin/radp-vf
  elif [[ -d "${SCRIPT_DIR}/../lib/radp_vagrant" ]]; then
    RADP_VF_HOME="$(cd "${SCRIPT_DIR}/.." && pwd)"
    RUBY_LIB_DIR="${RADP_VF_HOME}"
  else
    echo "Error: Cannot locate RADP Vagrant Framework. Set RADP_VF_HOME." >&2
    exit 1
  fi
else
  # RADP_VF_HOME is set via env var, detect RUBY_LIB_DIR
  if [[ -d "${RADP_VF_HOME}/src/main/ruby/lib/radp_vagrant" ]]; then
    RUBY_LIB_DIR="${RADP_VF_HOME}/src/main/ruby"
  elif [[ -d "${RADP_VF_HOME}/lib/radp_vagrant" ]]; then
    RUBY_LIB_DIR="${RADP_VF_HOME}"
  else
    echo "Error: Invalid RADP_VF_HOME: ${RADP_VF_HOME}" >&2
    exit 1
  fi
fi
export RADP_VF_HOME

# Global options
OPT_ENV=""
OPT_CONFIG=""

# Get version
# Priority: .install-version file > Ruby VERSION constant
get_version() {
  # Check for .install-version file first (written by install.sh for manual installs)
  if [[ -f "${RADP_VF_HOME}/.install-version" ]]; then
    cat "${RADP_VF_HOME}/.install-version"
    return 0
  fi

  # Fall back to Ruby VERSION constant
  (cd "${RUBY_LIB_DIR}" && ruby -r ./lib/radp_vagrant -e "puts RadpVagrant::VERSION" 2>/dev/null) || echo "unknown"
}

# Resolve config directory
# Priority: -c flag > RADP_VAGRANT_CONFIG_DIR > ./config (if exists)
resolve_config_dir() {
  local config_dir=""

  if [[ -n "${OPT_CONFIG}" ]]; then
    config_dir="${OPT_CONFIG}"
  elif [[ -n "${RADP_VAGRANT_CONFIG_DIR:-}" ]]; then
    config_dir="${RADP_VAGRANT_CONFIG_DIR}"
  elif [[ -d "./config" && -f "./config/vagrant.yaml" ]]; then
    config_dir="$(pwd)/config"
  fi

  if [[ -z "${config_dir}" ]]; then
    echo "Error: Cannot determine config directory." >&2
    echo "Use -c <dir>, set RADP_VAGRANT_CONFIG_DIR, or run from a directory containing config/vagrant.yaml" >&2
    return 1
  fi

  if [[ ! -f "${config_dir}/vagrant.yaml" ]]; then
    echo "Error: No vagrant.yaml found in ${config_dir}" >&2
    return 1
  fi

  echo "${config_dir}"
}

usage() {
  local version
  version="$(get_version)"
  cat <<USAGE
RADP Vagrant Framework CLI ${version}

Usage:
  radp-vf [options] <command> [args...]

Commands:
  init [dir]              Initialize a new project with sample configuration
  vg <vagrant-cmd>        Run vagrant command with framework
  list [options] [filter] List clusters and guests from configuration
  dump-config [options]   Dump merged configuration (use -o for file output)
  generate [output]       Generate standalone Vagrantfile
  validate                Validate YAML configuration files
  info                    Show environment and configuration info
  template <subcommand>   Manage project templates (list, show)
  completion <shell>      Generate shell completion script (bash, zsh)
  version                 Show version
  help                    Show this help

Init Options:
  -t, --template <name>   Use a template (default: base)
  --set <var>=<value>     Set template variable (can be repeated)

List Options:
  -v, --verbose           Show detailed info (box, network, provisions, etc.)
  --provisions            Show provisions only
  --synced-folders        Show synced folders only
  --triggers              Show triggers only

Global Options:
  -c, --config <dir>      Configuration directory (default: ./config)
  -e, --env <name>        Override environment name
  -v, --verbose           Enable verbose output
  -h, --help              Show this help
  --version               Show version

Environment Variables:
  RADP_VF_HOME            Framework installation directory
                          Current: ${RADP_VF_HOME}
  RADP_VAGRANT_CONFIG_DIR Configuration directory path
  RADP_VAGRANT_ENV        Override environment name

Priority (highest to lowest):
  -c flag > RADP_VAGRANT_CONFIG_DIR > ./config
  -e flag > RADP_VAGRANT_ENV > radp.env in vagrant.yaml

Examples:
  radp-vf init myproject
  radp-vf info
  radp-vf list
  radp-vf list -v
  radp-vf list -v node-1
  radp-vf list --provisions
  radp-vf list --synced-folders node-1
  radp-vf validate
  radp-vf dump-config
  radp-vf dump-config -f yaml
  radp-vf dump-config -o config.json
  radp-vf dump-config -f yaml -o config.yaml
  radp-vf dump-config node-1
  radp-vf generate Vagrantfile.standalone
  radp-vf -c /path/to/config vg status
  radp-vf -e prod vg up
USAGE
}

cmd_info() {
  local config_dir
  config_dir="$(resolve_config_dir 2>/dev/null)" || config_dir=""

  cd "${RUBY_LIB_DIR}"
  ruby -r ./lib/radp_vagrant -e "
    cmd = RadpVagrant::CLI::Info.new(
      '${config_dir}'.empty? ? nil : '${config_dir}',
      env_override: '${OPT_ENV}'.empty? ? nil : '${OPT_ENV}',
      radp_vf_home: '${RADP_VF_HOME}',
      ruby_lib_dir: '${RUBY_LIB_DIR}'
    )
    exit cmd.execute
  "
}

cmd_vg() {
  if [[ $# -eq 0 ]]; then
    echo "Usage: radp-vf vg <vagrant-command> [args...]" >&2
    echo "" >&2
    echo "Examples:" >&2
    echo "  radp-vf vg status" >&2
    echo "  radp-vf vg up" >&2
    echo "  radp-vf -e dev vg status" >&2
    echo "  radp-vf -c /path/to/config vg up" >&2
    return 1
  fi

  local config_dir
  config_dir="$(resolve_config_dir)" || return 1

  # Set environment override if specified
  if [[ -n "${OPT_ENV}" ]]; then
    export RADP_VAGRANT_ENV="${OPT_ENV}"
  fi

  # Use framework's Vagrantfile via VAGRANT_VAGRANTFILE
  export VAGRANT_VAGRANTFILE="${RUBY_LIB_DIR}/Vagrantfile"
  export RADP_VAGRANT_CONFIG_DIR="${config_dir}"
  export RADP_VF_HOME

  # Run vagrant (no need to change directory)
  exec vagrant "$@"
}

cmd_init() {
  local target_dir=""
  local template="base"
  local -a set_vars=()

  # Parse options
  while [[ $# -gt 0 ]]; do
    case "$1" in
      -t | --template)
        if [[ -z "${2:-}" ]]; then
          echo "Error: -t/--template requires a template name" >&2
          return 1
        fi
        template="$2"
        shift 2
        ;;
      --set)
        if [[ -z "${2:-}" ]]; then
          echo "Error: --set requires a variable assignment (var=value)" >&2
          return 1
        fi
        set_vars+=("$2")
        shift 2
        ;;
      -*)
        echo "Unknown option: $1" >&2
        echo "Usage: radp-vf init [dir] [-t|--template name] [--set var=value ...]" >&2
        return 1
        ;;
      *)
        if [[ -z "${target_dir}" ]]; then
          target_dir="$1"
        else
          echo "Error: Multiple target directories specified" >&2
          return 1
        fi
        shift
        ;;
    esac
  done

  target_dir="${target_dir:-.}"
  local abs_target_dir
  local abs_config_dir

  mkdir -p "${target_dir}"
  abs_target_dir="$(cd "${target_dir}" && pwd)"
  abs_config_dir="${abs_target_dir}/config"

  if [[ -f "${abs_config_dir}/vagrant.yaml" ]]; then
    echo "Error: Configuration already exists in ${abs_config_dir}" >&2
    exit 1
  fi

  echo "Initializing RADP Vagrant Framework project..."
  echo "Template: ${template}"
  echo ""

  # Build variables hash as JSON for Ruby
  local vars_json="{"
  local first=true
  for var in "${set_vars[@]}"; do
    if [[ "${var}" =~ ^([^=]+)=(.*)$ ]]; then
      local key="${BASH_REMATCH[1]}"
      local value="${BASH_REMATCH[2]}"
      if [[ "${first}" == "true" ]]; then
        first=false
      else
        vars_json+=","
      fi
      # Escape double quotes in value
      value="${value//\"/\\\"}"
      vars_json+="\"${key}\":\"${value}\""
    else
      echo "Error: Invalid variable format '${var}'. Use var=value" >&2
      return 1
    fi
  done
  vars_json+="}"

  # Call Ruby renderer
  cd "${RUBY_LIB_DIR}"
  local result
  result=$(ruby -r ./lib/radp_vagrant -r json -e "
    require_relative 'lib/radp_vagrant/templates/renderer'

    template_name = '${template}'
    target_dir = '${abs_target_dir}'
    variables = JSON.parse('${vars_json}')

    renderer = RadpVagrant::Templates::Renderer.new(template_name, variables)
    result = renderer.render_to(target_dir)

    if result[:success]
      puts 'SUCCESS'
      (result[:files] || []).each { |f| puts f }
    else
      puts 'ERROR'
      puts result[:error]
    end
  " 2>&1) || true

  # Parse result
  local status
  status=$(echo "${result}" | head -n1)

  if [[ "${status}" != "SUCCESS" ]]; then
    local error_msg
    error_msg=$(echo "${result}" | tail -n +2)
    echo "Error: ${error_msg}" >&2
    return 1
  fi

  # Get list of created files
  local files
  files=$(echo "${result}" | tail -n +2)

  echo "Project initialized successfully!"
  echo ""
  echo "Created in ${abs_target_dir}/:"
  echo "${files}" | while read -r file; do
    [[ -n "${file}" ]] && echo "  - ${file}"
  done
  echo ""
  echo "Framework:"
  echo "  RADP_VF_HOME: ${RADP_VF_HOME}"
  echo "  Vagrantfile:  ${RUBY_LIB_DIR}/Vagrantfile"
  echo ""
  echo "Provisions:"
  echo "  - Framework builtin:"
  echo "      radp:nfs/external-nfs-mount  - Mount external NFS shares"
  echo "      radp:ssh/host-trust          - Host -> Guest SSH trust"
  echo "      radp:ssh/cluster-trust       - Guest <-> Guest SSH trust"
  echo "      radp:time/chrony-sync        - Time synchronization"
  echo "  - User-defined: user:example (see provisions/definitions/example.yaml)"
  echo ""
  echo "Next steps:"
  echo "  # Option 1: Run from project directory"
  echo "  cd ${abs_target_dir}"
  echo "  radp-vf vg status"
  echo ""
  echo "  # Option 2: Run from anywhere"
  echo "  radp-vf -c ${abs_config_dir} vg status"
  echo ""
  echo "Edit vagrant.yaml to change 'env' and create your own environment file."
  echo "Add custom provisions in provisions/definitions/ with user: prefix."
  echo ""
  echo "Use 'radp-vf template list' to see all available templates."
}

cmd_list() {
  # Use global verbose if set, otherwise default to false
  local verbose="${OPT_VERBOSE:-false}"
  local show_provisions=false
  local show_synced_folders=false
  local show_triggers=false
  local filter=""

  # Parse list-specific options
  while [[ $# -gt 0 ]]; do
    case "$1" in
      -v | --verbose)
        verbose=true
        shift
        ;;
      --provisions)
        show_provisions=true
        shift
        ;;
      --synced-folders)
        show_synced_folders=true
        shift
        ;;
      --triggers)
        show_triggers=true
        shift
        ;;
      -*)
        echo "Unknown option: $1" >&2
        echo "Usage: radp-vf list [-v] [--provisions] [--synced-folders] [--triggers] [filter]" >&2
        return 1
        ;;
      *)
        filter="$1"
        shift
        ;;
    esac
  done

  local config_dir
  config_dir="$(resolve_config_dir)" || return 1

  cd "${RUBY_LIB_DIR}"
  ruby -r ./lib/radp_vagrant -e "
    cmd = RadpVagrant::CLI::List.new(
      '${config_dir}',
      env_override: '${OPT_ENV}'.empty? ? nil : '${OPT_ENV}',
      verbose: ${verbose},
      show_provisions: ${show_provisions},
      show_synced_folders: ${show_synced_folders},
      show_triggers: ${show_triggers},
      filter: '${filter}'.empty? ? nil : '${filter}'
    )
    exit cmd.execute
  "
}

cmd_dump_config() {
  local filter=""
  local format="json"
  local output=""

  # Parse dump-config specific options
  while [[ $# -gt 0 ]]; do
    case "$1" in
      -f | --format)
        if [[ -z "${2:-}" ]]; then
          echo "Error: -f requires a format (json or yaml)" >&2
          return 1
        fi
        format="$2"
        shift 2
        ;;
      -o | --output)
        if [[ -z "${2:-}" ]]; then
          echo "Error: -o requires an output file path" >&2
          return 1
        fi
        output="$2"
        shift 2
        ;;
      -*)
        echo "Unknown option: $1" >&2
        echo "Usage: radp-vf dump-config [-f json|yaml] [-o file] [filter]" >&2
        return 1
        ;;
      *)
        filter="$1"
        shift
        ;;
    esac
  done

  # Validate format
  if [[ "${format}" != "json" && "${format}" != "yaml" ]]; then
    echo "Error: Invalid format '${format}'. Use 'json' or 'yaml'." >&2
    return 1
  fi

  local config_dir
  config_dir="$(resolve_config_dir)" || return 1

  # Convert relative output path to absolute before changing directory
  if [[ -n "${output}" && "${output}" != /* ]]; then
    output="$(pwd)/${output}"
  fi

  cd "${RUBY_LIB_DIR}"
  ruby -r ./lib/radp_vagrant -e "
    cmd = RadpVagrant::CLI::DumpConfig.new(
      '${config_dir}',
      env_override: '${OPT_ENV}'.empty? ? nil : '${OPT_ENV}',
      filter: '${filter}'.empty? ? nil : '${filter}',
      format: :${format},
      output: '${output}'.empty? ? nil : '${output}'
    )
    exit cmd.execute
  "
}

cmd_generate() {
  local output="${1:-}"
  local config_dir
  config_dir="$(resolve_config_dir)" || return 1

  # Convert relative output path to absolute before changing directory
  if [[ -n "${output}" && "${output}" != /* ]]; then
    output="$(pwd)/${output}"
  fi

  cd "${RUBY_LIB_DIR}"
  ruby -r ./lib/radp_vagrant -e "
    cmd = RadpVagrant::CLI::Generate.new(
      '${config_dir}',
      env_override: '${OPT_ENV}'.empty? ? nil : '${OPT_ENV}',
      output: '${output}'.empty? ? nil : '${output}'
    )
    exit cmd.execute
  "
}

cmd_validate() {
  local config_dir
  config_dir="$(resolve_config_dir)" || return 1

  echo "Validating configuration..." >&2
  echo "Config Dir: ${config_dir}" >&2
  echo "" >&2

  cd "${RUBY_LIB_DIR}"
  ruby -r ./lib/radp_vagrant -e "
    cmd = RadpVagrant::CLI::Validate.new(
      '${config_dir}',
      env_override: '${OPT_ENV}'.empty? ? nil : '${OPT_ENV}'
    )
    exit cmd.execute
  "
}

cmd_template() {
  local subcommand="${1:-list}"
  shift || true

  cd "${RUBY_LIB_DIR}"
  ruby -r ./lib/radp_vagrant -e "
    cmd = RadpVagrant::CLI::Template.new('${subcommand}', ARGV)
    exit cmd.execute
  " -- "$@"
}

cmd_completion() {
  local shell="${1:-}"

  case "$shell" in
    bash)
      __radp_vf_completion_bash
      ;;
    zsh)
      __radp_vf_completion_zsh
      ;;
    "")
      echo "Usage: radp-vf completion <shell>" >&2
      echo "Supported shells: bash, zsh" >&2
      return 1
      ;;
    *)
      echo "Unsupported shell: $shell" >&2
      echo "Supported shells: bash, zsh" >&2
      return 1
      ;;
  esac
}

__radp_vf_completion_bash() {
  cat <<'BASH_COMPLETION'
# radp-vf bash completion
# Generated by radp-vagrant-framework

_radp_vf() {
    local cur prev words cword

    # Initialize completion variables
    if type _init_completion &>/dev/null; then
        _init_completion || return
    else
        COMPREPLY=()
        cur="${COMP_WORDS[COMP_CWORD]}"
        prev="${COMP_WORDS[COMP_CWORD-1]}"
        words=("${COMP_WORDS[@]}")
        cword=$COMP_CWORD
    fi

    local commands="init vg list dump-config generate validate info template completion version help"
    local global_opts="-c --config -e --env -v --verbose -h --help --version"

    # Handle command-specific completions
    case "${words[1]}" in
        init)
            local init_opts="-t --template --set"
            case "$cur" in
                -*)
                    COMPREPLY=($(compgen -W "$init_opts" -- "$cur"))
                    return
                    ;;
            esac
            case "$prev" in
                -t|--template)
                    # Template names would need dynamic completion
                    COMPREPLY=($(compgen -W "base single-node k8s-cluster" -- "$cur"))
                    return
                    ;;
            esac
            # Directory completion
            if type _filedir &>/dev/null; then
                _filedir -d
            else
                COMPREPLY=($(compgen -d -- "$cur"))
            fi
            return
            ;;
        vg)
            # Vagrant command completion
            local vagrant_cmds="up halt destroy status ssh provision reload suspend resume snapshot"
            COMPREPLY=($(compgen -W "$vagrant_cmds" -- "$cur"))
            return
            ;;
        list)
            local list_opts="-v --verbose --provisions --synced-folders --triggers"
            case "$cur" in
                -*)
                    COMPREPLY=($(compgen -W "$list_opts" -- "$cur"))
                    return
                    ;;
            esac
            # Filter argument (no completion)
            return
            ;;
        dump-config)
            local dump_opts="-f --format -o --output"
            case "$cur" in
                -*)
                    COMPREPLY=($(compgen -W "$dump_opts" -- "$cur"))
                    return
                    ;;
            esac
            case "$prev" in
                -f|--format)
                    COMPREPLY=($(compgen -W "json yaml" -- "$cur"))
                    return
                    ;;
                -o|--output)
                    if type _filedir &>/dev/null; then
                        _filedir
                    else
                        COMPREPLY=($(compgen -f -- "$cur"))
                    fi
                    return
                    ;;
            esac
            return
            ;;
        generate)
            # Output file completion
            if type _filedir &>/dev/null; then
                _filedir
            else
                COMPREPLY=($(compgen -f -- "$cur"))
            fi
            return
            ;;
        validate|info|version|help)
            # No arguments
            return
            ;;
        template)
            # Template subcommands
            case "${words[2]:-}" in
                list)
                    return
                    ;;
                show)
                    # Template names
                    COMPREPLY=($(compgen -W "base single-node k8s-cluster" -- "$cur"))
                    return
                    ;;
                "")
                    COMPREPLY=($(compgen -W "list show" -- "$cur"))
                    return
                    ;;
            esac
            return
            ;;
        completion)
            COMPREPLY=($(compgen -W "bash zsh" -- "$cur"))
            return
            ;;
    esac

    # Top-level completion (no command selected yet)
    case "$cur" in
        -*)
            COMPREPLY=($(compgen -W "$global_opts" -- "$cur"))
            ;;
        *)
            COMPREPLY=($(compgen -W "$commands" -- "$cur"))
            ;;
    esac
}

complete -F _radp_vf radp-vf
BASH_COMPLETION
}

__radp_vf_completion_zsh() {
  cat <<'ZSH_COMPLETION'
#compdef radp-vf
# radp-vf zsh completion
# Generated by radp-vagrant-framework

# Subcommand functions
_radp_vf_init() {
    _arguments -s \
        '(-h --help)'{-h,--help}'[Show help]' \
        '(-t --template)'{-t,--template}'[Use a template]:template:(base single-node k8s-cluster)' \
        '*--set[Set template variable]:variable:' \
        '1:directory:_files -/'
}

_radp_vf_vg() {
    local -a vagrant_cmds=(
        'up:Start and provision VMs'
        'halt:Stop VMs'
        'destroy:Destroy VMs'
        'status:Show VM status'
        'ssh:SSH into VM'
        'provision:Run provisioners'
        'reload:Restart VMs'
        'suspend:Suspend VMs'
        'resume:Resume suspended VMs'
        'snapshot:Manage snapshots'
    )
    _arguments -s \
        '(-h --help)'{-h,--help}'[Show help]' \
        '1: :->vagrant_cmd' \
        '*:: :->vagrant_args'

    case "$state" in
        vagrant_cmd)
            _describe -t commands 'vagrant command' vagrant_cmds
            ;;
        vagrant_args)
            # Let vagrant handle its own completion
            _files
            ;;
    esac
}

_radp_vf_list() {
    _arguments -s \
        '(-h --help)'{-h,--help}'[Show help]' \
        '(-v --verbose)'{-v,--verbose}'[Show detailed info]' \
        '--provisions[Show provisions only]' \
        '--synced-folders[Show synced folders only]' \
        '--triggers[Show triggers only]' \
        '1:filter:'
}

_radp_vf_dump_config() {
    _arguments -s \
        '(-h --help)'{-h,--help}'[Show help]' \
        '(-f --format)'{-f,--format}'[Output format]:format:(json yaml)' \
        '(-o --output)'{-o,--output}'[Output file]:file:_files' \
        '1:filter:'
}

_radp_vf_generate() {
    _arguments -s \
        '(-h --help)'{-h,--help}'[Show help]' \
        '1:output file:_files'
}

_radp_vf_validate() {
    _arguments -s '(-h --help)'{-h,--help}'[Show help]'
}

_radp_vf_info() {
    _arguments -s '(-h --help)'{-h,--help}'[Show help]'
}

_radp_vf_template() {
    local -a template_cmds=(
        'list:List available templates'
        'show:Show template details'
    )

    local context state state_descr line
    typeset -A opt_args

    _arguments -C \
        '(-h --help)'{-h,--help}'[Show help]' \
        '1: :->subcmd' \
        '*:: :->args'

    case "$state" in
        subcmd)
            _describe -t commands 'template subcommand' template_cmds
            ;;
        args)
            local cmd_func="_radp_vf_template_${words[1]//-/_}"
            if (( $+functions[$cmd_func] )); then
                $cmd_func
            fi
            ;;
    esac
}

_radp_vf_template_list() {
    _arguments -s '(-h --help)'{-h,--help}'[Show help]'
}

_radp_vf_template_show() {
    _arguments -s \
        '(-h --help)'{-h,--help}'[Show help]' \
        '1:template:(base single-node k8s-cluster)'
}

_radp_vf_completion() {
    _arguments -s \
        '(-h --help)'{-h,--help}'[Show help]' \
        '1:shell:(bash zsh)'
}

_radp_vf_version() {
    _arguments -s '(-h --help)'{-h,--help}'[Show help]'
}

_radp_vf_help() {
    _arguments -s '(-h --help)'{-h,--help}'[Show help]'
}

# Main completion function
_radp_vf() {
    local -a commands=(
        'init:Initialize a new project with sample configuration'
        'vg:Run vagrant command with framework'
        'list:List clusters and guests from configuration'
        'dump-config:Dump merged configuration'
        'generate:Generate standalone Vagrantfile'
        'validate:Validate YAML configuration files'
        'info:Show environment and configuration info'
        'template:Manage project templates'
        'completion:Generate shell completion script'
        'version:Show version'
        'help:Show help'
    )

    local context state state_descr line
    typeset -A opt_args

    _arguments -C \
        '(-h --help)'{-h,--help}'[Show help]' \
        '(-c --config)'{-c,--config}'[Configuration directory]:dir:_files -/' \
        '(-e --env)'{-e,--env}'[Override environment name]:env:' \
        '(-v --verbose)'{-v,--verbose}'[Enable verbose output]' \
        '--version[Show version]' \
        '1: :->command' \
        '*:: :->args'

    case "$state" in
        command)
            _describe -t commands 'command' commands
            ;;
        args)
            local cmd_func="_radp_vf_${words[1]//-/_}"
            if (( $+functions[$cmd_func] )); then
                $cmd_func
            else
                _files
            fi
            ;;
    esac
}

_radp_vf "$@"
ZSH_COMPLETION
}

cmd_version() {
  get_version
}

main() {
  # Parse global options
  while [[ $# -gt 0 ]]; do
    case "$1" in
      -c | --config)
        if [[ -z "${2:-}" ]]; then
          echo "Error: -c requires a config directory path" >&2
          exit 1
        fi
        OPT_CONFIG="$2"
        shift 2
        ;;
      -e | --env)
        if [[ -z "${2:-}" ]]; then
          echo "Error: -e requires an environment name" >&2
          exit 1
        fi
        OPT_ENV="$2"
        shift 2
        ;;
      -v | --verbose)
        OPT_VERBOSE=true
        shift
        ;;
      -h | --help)
        usage
        exit 0
        ;;
      --version)
        cmd_version
        exit 0
        ;;
      -*)
        echo "Unknown option: $1" >&2
        usage >&2
        exit 1
        ;;
      *)
        break
        ;;
    esac
  done

  local cmd="${1:-help}"
  shift || true

  case "${cmd}" in
    init)
      cmd_init "$@"
      ;;
    vg)
      cmd_vg "$@"
      ;;
    list)
      cmd_list "$@"
      ;;
    info)
      cmd_info "$@"
      ;;
    dump-config | dump_config)
      cmd_dump_config "$@"
      ;;
    generate)
      cmd_generate "$@"
      ;;
    validate)
      cmd_validate "$@"
      ;;
    template)
      cmd_template "$@"
      ;;
    completion)
      cmd_completion "$@"
      ;;
    version)
      cmd_version
      ;;
    help)
      usage
      ;;
    *)
      echo "Unknown command: ${cmd}" >&2
      usage >&2
      exit 1
      ;;
  esac
}

main "$@"
