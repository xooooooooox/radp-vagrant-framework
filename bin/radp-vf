#!/usr/bin/env bash
# RADP Vagrant Framework CLI
# https://github.com/xooooooooox/radp-vagrant-framework

set -euo pipefail

# Resolve script directory (handle symlinks)
resolve_script_dir() {
  local source="${BASH_SOURCE[0]}"
  while [[ -L "${source}" ]]; do
    local dir
    dir="$(cd -P "$(dirname "${source}")" && pwd)"
    source="$(readlink "${source}")"
    [[ "${source}" != /* ]] && source="${dir}/${source}"
  done
  cd -P "$(dirname "${source}")" && pwd
}

SCRIPT_DIR="$(resolve_script_dir)"

# Determine RADP_VF_HOME and RUBY_LIB_DIR
# Priority: env var > auto-detect from script location
#
# Two installation modes:
# 1. Development (git clone): bin/radp-vf in project root
#    - RADP_VF_HOME = project_root
#    - RUBY_LIB_DIR = project_root/src/main/ruby
#
# 2. Homebrew/installed: libexec/bin/radp-vf
#    - RADP_VF_HOME = libexec (contains Vagrantfile, lib/ directly)
#    - RUBY_LIB_DIR = libexec (same as RADP_VF_HOME)

if [[ -z "${RADP_VF_HOME:-}" ]]; then
  # Case 1: Development mode - project_root/bin/radp-vf
  if [[ -d "${SCRIPT_DIR}/../src/main/ruby/lib/radp_vagrant" ]]; then
    RADP_VF_HOME="$(cd "${SCRIPT_DIR}/.." && pwd)"
    RUBY_LIB_DIR="${RADP_VF_HOME}/src/main/ruby"
  # Case 2: Homebrew/installed mode - libexec/bin/radp-vf
  elif [[ -d "${SCRIPT_DIR}/../lib/radp_vagrant" ]]; then
    RADP_VF_HOME="$(cd "${SCRIPT_DIR}/.." && pwd)"
    RUBY_LIB_DIR="${RADP_VF_HOME}"
  else
    echo "Error: Cannot locate RADP Vagrant Framework. Set RADP_VF_HOME." >&2
    exit 1
  fi
else
  # RADP_VF_HOME is set via env var, detect RUBY_LIB_DIR
  if [[ -d "${RADP_VF_HOME}/src/main/ruby/lib/radp_vagrant" ]]; then
    RUBY_LIB_DIR="${RADP_VF_HOME}/src/main/ruby"
  elif [[ -d "${RADP_VF_HOME}/lib/radp_vagrant" ]]; then
    RUBY_LIB_DIR="${RADP_VF_HOME}"
  else
    echo "Error: Invalid RADP_VF_HOME: ${RADP_VF_HOME}" >&2
    exit 1
  fi
fi
export RADP_VF_HOME

# Global options
OPT_ENV=""
OPT_CONFIG=""

# Get version
get_version() {
  (cd "${RUBY_LIB_DIR}" && ruby -r ./lib/radp_vagrant -e "puts RadpVagrant::VERSION" 2>/dev/null) || echo "unknown"
}

# Resolve config directory
# Priority: -c flag > RADP_VAGRANT_CONFIG_DIR > ./config (if exists)
resolve_config_dir() {
  local config_dir=""

  if [[ -n "${OPT_CONFIG}" ]]; then
    config_dir="${OPT_CONFIG}"
  elif [[ -n "${RADP_VAGRANT_CONFIG_DIR:-}" ]]; then
    config_dir="${RADP_VAGRANT_CONFIG_DIR}"
  elif [[ -d "./config" && -f "./config/vagrant.yaml" ]]; then
    config_dir="$(pwd)/config"
  fi

  if [[ -z "${config_dir}" ]]; then
    echo "Error: Cannot determine config directory." >&2
    echo "Use -c <dir>, set RADP_VAGRANT_CONFIG_DIR, or run from a directory containing config/vagrant.yaml" >&2
    return 1
  fi

  if [[ ! -f "${config_dir}/vagrant.yaml" ]]; then
    echo "Error: No vagrant.yaml found in ${config_dir}" >&2
    return 1
  fi

  echo "${config_dir}"
}

usage() {
  local version
  version="$(get_version)"
  cat << USAGE
RADP Vagrant Framework CLI ${version}

Usage:
  radp-vf [options] <command> [args...]

Commands:
  init [dir]              Initialize a new project with sample configuration
  vg <vagrant-cmd>        Run vagrant command with framework
  list                    List clusters and guests from configuration
  dump-config [options]   Dump merged configuration (use -o for file output)
  generate [output]       Generate standalone Vagrantfile
  validate                Validate YAML configuration files
  info                    Show environment and configuration info
  version                 Show version
  help                    Show this help

Global Options:
  -c, --config <dir>      Configuration directory (default: ./config)
  -e, --env <name>        Override environment name

Environment Variables:
  RADP_VF_HOME            Framework installation directory
                          Current: ${RADP_VF_HOME}
  RADP_VAGRANT_CONFIG_DIR Configuration directory path
  RADP_VAGRANT_ENV        Override environment name

Priority (highest to lowest):
  -c flag > RADP_VAGRANT_CONFIG_DIR > ./config
  -e flag > RADP_VAGRANT_ENV > radp.env in vagrant.yaml

Examples:
  radp-vf init myproject
  radp-vf info
  radp-vf list
  radp-vf validate
  radp-vf dump-config
  radp-vf dump-config -f yaml
  radp-vf dump-config -o config.json
  radp-vf dump-config -f yaml -o config.yaml
  radp-vf dump-config node-1
  radp-vf generate Vagrantfile.standalone
  radp-vf -c /path/to/config vg status
  radp-vf -e prod vg up
USAGE
}

cmd_info() {
  local version
  version="$(get_version)"

  echo "RADP Vagrant Framework"
  echo ""
  echo "Framework:"
  echo "  Version:      ${version}"
  echo "  RADP_VF_HOME: ${RADP_VF_HOME}"
  echo "  Vagrantfile:  ${RUBY_LIB_DIR}/Vagrantfile"
  echo ""
  echo "Environment Variables:"
  echo "  RADP_VAGRANT_CONFIG_DIR: ${RADP_VAGRANT_CONFIG_DIR:-(not set)}"
  echo "  RADP_VAGRANT_ENV:        ${RADP_VAGRANT_ENV:-(not set)}"

  # Try to resolve config directory
  local config_dir
  config_dir="$(resolve_config_dir 2>/dev/null)" || true

  if [[ -n "${config_dir}" ]]; then
    echo ""
    echo "Resolved Configuration:"
    echo "  Config Dir:   ${config_dir}"

    if [[ -f "${config_dir}/vagrant.yaml" ]]; then
      local env_name
      env_name="$(grep -E '^\s*env:' "${config_dir}/vagrant.yaml" 2>/dev/null | head -1 | sed 's/.*env:\s*//' | tr -d ' ')"
      local effective_env="${OPT_ENV:-${RADP_VAGRANT_ENV:-${env_name}}}"
      echo "  Environment:  ${effective_env:-unknown}"
      if [[ -n "${OPT_ENV}" ]]; then
        echo "                (from -e flag)"
      elif [[ -n "${RADP_VAGRANT_ENV:-}" ]]; then
        echo "                (from RADP_VAGRANT_ENV)"
      else
        echo "                (from vagrant.yaml)"
      fi
      echo ""
      echo "Config Files:"
      echo "  Base: ${config_dir}/vagrant.yaml"
      if [[ -n "${effective_env}" && -f "${config_dir}/vagrant-${effective_env}.yaml" ]]; then
        echo "  Env:  ${config_dir}/vagrant-${effective_env}.yaml"
      elif [[ -n "${effective_env}" ]]; then
        echo "  Env:  ${config_dir}/vagrant-${effective_env}.yaml (not found)"
      fi
    fi
  else
    echo ""
    echo "Configuration: (not resolved)"
    echo "  Use -c <dir>, set RADP_VAGRANT_CONFIG_DIR, or run from a directory with config/vagrant.yaml"
    echo "  Or run 'radp-vf init <dir>' to create a new project."
  fi
}

cmd_vg() {
  if [[ $# -eq 0 ]]; then
    echo "Usage: radp-vf vg <vagrant-command> [args...]" >&2
    echo "" >&2
    echo "Examples:" >&2
    echo "  radp-vf vg status" >&2
    echo "  radp-vf vg up" >&2
    echo "  radp-vf -e dev vg status" >&2
    echo "  radp-vf -c /path/to/config vg up" >&2
    return 1
  fi

  local config_dir
  config_dir="$(resolve_config_dir)" || return 1

  # Set environment override if specified
  if [[ -n "${OPT_ENV}" ]]; then
    export RADP_VAGRANT_ENV="${OPT_ENV}"
  fi

  # Use framework's Vagrantfile via VAGRANT_VAGRANTFILE
  export VAGRANT_VAGRANTFILE="${RUBY_LIB_DIR}/Vagrantfile"
  export RADP_VAGRANT_CONFIG_DIR="${config_dir}"
  export RADP_VF_HOME

  # Run vagrant (no need to change directory)
  exec vagrant "$@"
}

cmd_init() {
  local target_dir="${1:-.}"
  local abs_target_dir
  local abs_config_dir

  mkdir -p "${target_dir}"
  abs_target_dir="$(cd "${target_dir}" && pwd)"
  abs_config_dir="${abs_target_dir}/config"

  if [[ -f "${abs_config_dir}/vagrant.yaml" ]]; then
    echo "Error: Configuration already exists in ${abs_config_dir}" >&2
    exit 1
  fi

  echo "Initializing RADP Vagrant Framework project..."
  echo ""

  mkdir -p "${abs_config_dir}"

  # Create sample vagrant.yaml
  cat > "${abs_config_dir}/vagrant.yaml" << 'VAGRANT_YAML'
radp:
  env: sample
  extend:
    vagrant:
      plugins:
        - name: vagrant-hostmanager
          required: true
          options:
            enabled: true
            manage_host: true
            manage_guest: true
      config:
        common:
          # Global settings inherited by all guests
VAGRANT_YAML

  # Create sample vagrant-sample.yaml
  cat > "${abs_config_dir}/vagrant-sample.yaml" << 'VAGRANT_DEV_YAML'
radp:
  extend:
    vagrant:
      config:
        clusters:
          - name: example
            common:
              box:
                name: generic/ubuntu2204
            guests:
              - id: node-1
                provider:
                  mem: 2048
                  cpus: 2
                network:
                  private-network:
                    enabled: true
                    type: dhcp
VAGRANT_DEV_YAML

  # Create user provisions directory structure with example
  local provisions_dir="${abs_config_dir}/provisions"
  mkdir -p "${provisions_dir}/definitions"
  mkdir -p "${provisions_dir}/scripts"

  # Create example user provision definition
  cat > "${provisions_dir}/definitions/example.yaml" << 'PROVISION_DEF'
# Example user provision definition
# Usage in vagrant.yaml or vagrant-{env}.yaml:
#   provisions:
#     - name: user:example
#       enabled: true
#       env:
#         MESSAGE: "Hello from user provision"
desc: Example user provision - demonstrates user-defined provisions
defaults:
  privileged: false
  run: once
  env:
    required: []
    optional:
      - name: MESSAGE
        value: "Hello World"
        desc: Message to display during provisioning
  script: example.sh
PROVISION_DEF

  # Create example user provision script
  cat > "${provisions_dir}/scripts/example.sh" << 'PROVISION_SCRIPT'
#!/usr/bin/env bash
set -euo pipefail

# Example user provision script
# This script is executed when the provision runs
#
# Environment variables from provision config are available:
#   ${MESSAGE} - example variable

echo "[INFO] Running example user provision"
echo "[INFO] MESSAGE=${MESSAGE:-not set}"
echo "[INFO] User provision completed"
PROVISION_SCRIPT

  chmod +x "${provisions_dir}/scripts/example.sh"

  echo "Project initialized successfully!"
  echo ""
  echo "Created:"
  echo "  ${abs_config_dir}/"
  echo "  ├── vagrant.yaml              # Base config (env: sample)"
  echo "  ├── vagrant-sample.yaml       # Cluster definitions"
  echo "  └── provisions/               # User-defined provisions"
  echo "      ├── definitions/"
  echo "      │   └── example.yaml      # Example provision definition"
  echo "      └── scripts/"
  echo "          └── example.sh        # Example provision script"
  echo ""
  echo "Framework:"
  echo "  RADP_VF_HOME: ${RADP_VF_HOME}"
  echo "  Vagrantfile:  ${RUBY_LIB_DIR}/Vagrantfile"
  echo ""
  echo "Provisions:"
  echo "  - Framework builtin:"
  echo "      radp:nfs/external-nfs-mount  - Mount external NFS shares"
  echo "      radp:ssh/host-trust          - Host -> Guest SSH trust"
  echo "      radp:ssh/cluster-trust       - Guest <-> Guest SSH trust"
  echo "      radp:time/chrony-sync        - Time synchronization"
  echo "  - User-defined: user:example (see provisions/definitions/example.yaml)"
  echo ""
  echo "Next steps:"
  echo "  # Option 1: Run from project directory"
  echo "  cd ${abs_target_dir}"
  echo "  radp-vf vg status"
  echo ""
  echo "  # Option 2: Run from anywhere"
  echo "  radp-vf -c ${abs_config_dir} vg status"
  echo ""
  echo "Edit vagrant.yaml to change 'env' and create your own environment file."
  echo "Add custom provisions in provisions/definitions/ with user: prefix."
}

cmd_list() {
  local config_dir
  config_dir="$(resolve_config_dir)" || return 1

  # Set environment override if specified
  local env_override=""
  if [[ -n "${OPT_ENV}" ]]; then
    env_override=", env_override: '${OPT_ENV}'"
  fi

  cd "${RUBY_LIB_DIR}"
  ruby -r ./lib/radp_vagrant -e "
    require 'yaml'

    config_dir = '${config_dir}'
    env_override = '${OPT_ENV}'.empty? ? nil : '${OPT_ENV}'

    # Override environment if specified
    ENV['RADP_VAGRANT_ENV'] = env_override if env_override

    merged = RadpVagrant.build_merged_config(config_dir)
    unless merged
      puts 'No vagrant configuration found'
      exit 1
    end

    env = merged['env']
    clusters = merged['clusters'] || []

    puts \"Environment: #{env}\"
    puts \"Config Dir:  #{config_dir}\"
    puts ''

    if clusters.empty?
      puts 'No clusters defined'
      exit 0
    end

    total_guests = clusters.sum { |c| c['guests'].size }
    puts \"Clusters: #{clusters.size} (#{total_guests} guests total)\"
    puts ''

    clusters.each do |cluster|
      guests = cluster['guests'] || []
      puts \"  #{cluster['name']} (#{guests.size} guests)\"

      guests.each_with_index do |guest, idx|
        prefix = idx == guests.size - 1 ? '└──' : '├──'
        machine_name = guest.dig('provider', 'name') || guest['id']
        ip = guest.dig('network', 'private-network', 'ip') || 'dhcp'
        mem = guest.dig('provider', 'mem') || '-'
        cpus = guest.dig('provider', 'cpus') || '-'

        puts \"    #{prefix} #{machine_name.ljust(25)} #{ip.to_s.ljust(16)} #{mem.to_s.rjust(5)}MB  #{cpus}CPU\"
      end
      puts ''
    end
  "
}

cmd_dump_config() {
  local filter=""
  local format="json"
  local output=""

  # Parse dump-config specific options
  while [[ $# -gt 0 ]]; do
    case "$1" in
      -f|--format)
        if [[ -z "${2:-}" ]]; then
          echo "Error: -f requires a format (json or yaml)" >&2
          return 1
        fi
        format="$2"
        shift 2
        ;;
      -o|--output)
        if [[ -z "${2:-}" ]]; then
          echo "Error: -o requires an output file path" >&2
          return 1
        fi
        output="$2"
        shift 2
        ;;
      -*)
        echo "Unknown option: $1" >&2
        echo "Usage: radp-vf dump-config [-f json|yaml] [-o file] [filter]" >&2
        return 1
        ;;
      *)
        filter="$1"
        shift
        ;;
    esac
  done

  # Validate format
  if [[ "${format}" != "json" && "${format}" != "yaml" ]]; then
    echo "Error: Invalid format '${format}'. Use 'json' or 'yaml'." >&2
    return 1
  fi

  local config_dir
  config_dir="$(resolve_config_dir)" || return 1

  # Convert relative output path to absolute before changing directory
  if [[ -n "${output}" && "${output}" != /* ]]; then
    output="$(pwd)/${output}"
  fi

  # Set environment override if specified
  if [[ -n "${OPT_ENV}" ]]; then
    export RADP_VAGRANT_ENV="${OPT_ENV}"
  fi

  echo "Config Dir: ${config_dir}" >&2
  echo "Format:     ${format}" >&2
  if [[ -n "${filter}" ]]; then
    echo "Filter:     ${filter}" >&2
  fi
  if [[ -n "${output}" ]]; then
    echo "Output:     ${output}" >&2
  fi
  echo "" >&2

  cd "${RUBY_LIB_DIR}"

  local ruby_cmd
  if [[ -n "${filter}" ]]; then
    ruby_cmd="RadpVagrant.dump_config('${config_dir}', '${filter}', format: :${format})"
  else
    ruby_cmd="RadpVagrant.dump_config('${config_dir}', nil, format: :${format})"
  fi

  if [[ -n "${output}" ]]; then
    ruby -r ./lib/radp_vagrant -e "${ruby_cmd}" > "${output}"
    echo "Written to: ${output}" >&2
  else
    ruby -r ./lib/radp_vagrant -e "${ruby_cmd}"
  fi
}

cmd_generate() {
  local output="${1:-}"
  local config_dir
  config_dir="$(resolve_config_dir)" || return 1

  # Convert relative output path to absolute before changing directory
  if [[ -n "${output}" && "${output}" != /* ]]; then
    output="$(pwd)/${output}"
  fi

  # Set environment override if specified
  if [[ -n "${OPT_ENV}" ]]; then
    export RADP_VAGRANT_ENV="${OPT_ENV}"
  fi

  echo "Config Dir: ${config_dir}" >&2
  if [[ -n "${output}" ]]; then
    echo "Output:     ${output}" >&2
  fi
  echo "" >&2

  cd "${RUBY_LIB_DIR}"
  if [[ -n "${output}" ]]; then
    ruby -r ./lib/radp_vagrant -e "RadpVagrant.generate_vagrantfile('${config_dir}', '${output}')"
    echo "Generated: ${output}" >&2
  else
    ruby -r ./lib/radp_vagrant -e "puts RadpVagrant.generate_vagrantfile('${config_dir}')"
  fi
}

cmd_validate() {
  local config_dir
  config_dir="$(resolve_config_dir)" || return 1

  # Set environment override if specified
  if [[ -n "${OPT_ENV}" ]]; then
    export RADP_VAGRANT_ENV="${OPT_ENV}"
  fi

  echo "Validating configuration..." >&2
  echo "Config Dir: ${config_dir}" >&2
  echo "" >&2

  cd "${RUBY_LIB_DIR}"
  ruby -r ./lib/radp_vagrant -e "
    require 'yaml'

    config_dir = '${config_dir}'
    errors = []
    warnings = []

    # Check vagrant.yaml exists
    base_file = File.join(config_dir, 'vagrant.yaml')
    unless File.exist?(base_file)
      errors << \"Base config file not found: #{base_file}\"
    end

    begin
      # Load and validate using framework
      config = RadpVagrant::ConfigLoader.load(config_dir)

      env = config.dig('radp', '_resolved_env')
      env_file = File.join(config_dir, \"vagrant-#{env}.yaml\")

      puts \"Base config:  #{base_file}\"
      puts \"Environment:  #{env}\"
      puts \"Env config:   #{env_file}#{File.exist?(env_file) ? '' : ' (not found)'}\"
      puts ''

      vagrant_section = config.dig('radp', 'extend', 'vagrant')
      unless vagrant_section
        errors << 'No vagrant configuration found (radp.extend.vagrant is missing)'
      else
        clusters = vagrant_section.dig('config', 'clusters') || []

        if clusters.empty?
          warnings << 'No clusters defined'
        else
          # Check for duplicate cluster names
          cluster_names = clusters.map { |c| c['name'] }
          duplicates = cluster_names.select { |n| cluster_names.count(n) > 1 }.uniq
          duplicates.each do |name|
            errors << \"Duplicate cluster name: #{name}\"
          end

          # Check each cluster
          clusters.each do |cluster|
            cluster_name = cluster['name'] || 'unnamed'
            guests = cluster['guests'] || []

            if guests.empty?
              warnings << \"Cluster '#{cluster_name}' has no guests\"
            else
              # Check for duplicate guest IDs within cluster
              guest_ids = guests.map { |g| g['id'] }
              dup_guests = guest_ids.select { |id| guest_ids.count(id) > 1 }.uniq
              dup_guests.each do |id|
                errors << \"Duplicate guest ID '#{id}' in cluster '#{cluster_name}'\"
              end

              # Check each guest has required fields
              guests.each do |guest|
                unless guest['id']
                  errors << \"Guest in cluster '#{cluster_name}' is missing 'id'\"
                end
              end
            end
          end

          puts \"Clusters:     #{clusters.size}\"
          total_guests = clusters.sum { |c| (c['guests'] || []).size }
          puts \"Guests:       #{total_guests}\"
        end

        # Check plugins
        plugins = vagrant_section['plugins'] || []
        required_plugins = plugins.select { |p| p['required'] }.map { |p| p['name'] }
        unless required_plugins.empty?
          puts \"Required plugins: #{required_plugins.join(', ')}\"
        end
      end

    rescue => e
      errors << \"Configuration error: #{e.message}\"
    end

    puts ''

    if warnings.any?
      puts \"Warnings:\"
      warnings.each { |w| puts \"  - #{w}\" }
      puts ''
    end

    if errors.any?
      puts \"Errors:\"
      errors.each { |e| puts \"  - #{e}\" }
      puts ''
      puts 'Validation FAILED'
      exit 1
    else
      puts 'Validation OK'
    end
  "
}

cmd_version() {
  get_version
}

main() {
  # Parse global options
  while [[ $# -gt 0 ]]; do
    case "$1" in
      -c|--config)
        if [[ -z "${2:-}" ]]; then
          echo "Error: -c requires a config directory path" >&2
          exit 1
        fi
        OPT_CONFIG="$2"
        shift 2
        ;;
      -e|--env)
        if [[ -z "${2:-}" ]]; then
          echo "Error: -e requires an environment name" >&2
          exit 1
        fi
        OPT_ENV="$2"
        shift 2
        ;;
      -*)
        # Check if it's a help/version flag
        case "$1" in
          -h|--help)
            usage
            exit 0
            ;;
          -v|--version)
            cmd_version
            exit 0
            ;;
          *)
            echo "Unknown option: $1" >&2
            usage >&2
            exit 1
            ;;
        esac
        ;;
      *)
        break
        ;;
    esac
  done

  local cmd="${1:-help}"
  shift || true

  case "${cmd}" in
    init)
      cmd_init "$@"
      ;;
    vg)
      cmd_vg "$@"
      ;;
    list)
      cmd_list "$@"
      ;;
    info)
      cmd_info "$@"
      ;;
    dump-config|dump_config)
      cmd_dump_config "$@"
      ;;
    generate)
      cmd_generate "$@"
      ;;
    validate)
      cmd_validate "$@"
      ;;
    version)
      cmd_version
      ;;
    help)
      usage
      ;;
    *)
      echo "Unknown command: ${cmd}" >&2
      usage >&2
      exit 1
      ;;
  esac
}

main "$@"
