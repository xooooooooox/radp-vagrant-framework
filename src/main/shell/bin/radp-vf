#!/usr/bin/env bash
# RADP Vagrant Framework CLI
# https://github.com/xooooooooox/radp-vagrant-framework

set -euo pipefail

# Resolve script directory (handle symlinks)
resolve_script_dir() {
  local source="${BASH_SOURCE[0]}"
  while [[ -L "${source}" ]]; do
    local dir
    dir="$(cd -P "$(dirname "${source}")" && pwd)"
    source="$(readlink "${source}")"
    [[ "${source}" != /* ]] && source="${dir}/${source}"
  done
  cd -P "$(dirname "${source}")" && pwd
}

SCRIPT_DIR="$(resolve_script_dir)"

# Determine RADP_VF_HOME
# Priority: env var > installed location > source repo layout
if [[ -z "${RADP_VF_HOME:-}" ]]; then
  # Check if we're in installed layout: bin/radp-vf with lib/ as sibling
  if [[ -d "${SCRIPT_DIR}/../lib/radp_vagrant" ]]; then
    RADP_VF_HOME="$(cd "${SCRIPT_DIR}/.." && pwd)"
  # Check source repo layout: src/main/shell/bin/radp-vf
  elif [[ -d "${SCRIPT_DIR}/../../ruby/lib/radp_vagrant" ]]; then
    RADP_VF_HOME="$(cd "${SCRIPT_DIR}/../../ruby" && pwd)"
  else
    echo "Error: Cannot locate RADP Vagrant Framework. Set RADP_VF_HOME." >&2
    exit 1
  fi
fi
export RADP_VF_HOME

# Global options
OPT_ENV=""

# Get version
get_version() {
  (cd "${RADP_VF_HOME}" && ruby -r ./lib/radp_vagrant -e "puts RadpVagrant::VERSION" 2>/dev/null) || echo "unknown"
}

# Resolve project directory
# Priority: RADP_VF_PROJECT_DIR > derived from RADP_VAGRANT_CONFIG_DIR > current dir
resolve_project_dir() {
  local project_dir=""

  if [[ -n "${RADP_VF_PROJECT_DIR:-}" ]]; then
    project_dir="${RADP_VF_PROJECT_DIR}"
  elif [[ -n "${RADP_VAGRANT_CONFIG_DIR:-}" ]]; then
    # Derive from config dir
    if [[ "${RADP_VAGRANT_CONFIG_DIR}" == */config ]]; then
      project_dir="${RADP_VAGRANT_CONFIG_DIR%/config}"
    else
      project_dir="${RADP_VAGRANT_CONFIG_DIR}"
    fi
  elif [[ -f "Vagrantfile" ]]; then
    project_dir="$(pwd)"
  fi

  if [[ -z "${project_dir}" ]]; then
    echo "Error: Cannot determine project directory." >&2
    echo "Set RADP_VF_PROJECT_DIR or RADP_VAGRANT_CONFIG_DIR, or run from a project directory." >&2
    return 1
  fi

  if [[ ! -f "${project_dir}/Vagrantfile" ]]; then
    echo "Error: No Vagrantfile found in ${project_dir}" >&2
    return 1
  fi

  echo "${project_dir}"
}

usage() {
  local version
  version="$(get_version)"
  cat << USAGE
RADP Vagrant Framework CLI ${version}

Usage:
  radp-vf [options] <command> [args...]

Commands:
  init [dir]              Initialize a new project with sample configuration
  vg <vagrant-cmd>        Run vagrant command in project directory
  dump-config [filter]    Dump merged configuration (JSON)
  generate [output]       Generate standalone Vagrantfile
  info                    Show environment and configuration info
  version                 Show version
  help                    Show this help

Options:
  -e, --env <name>        Override environment (used with vg command)

Environment Variables:
  RADP_VF_HOME            Framework installation directory
                          Current: ${RADP_VF_HOME}
  RADP_VF_PROJECT_DIR     Project directory containing Vagrantfile
  RADP_VAGRANT_CONFIG_DIR Configuration directory path
                          Default: ./config (relative to Vagrantfile)
  RADP_VAGRANT_ENV        Override environment name

Environment Priority (highest to lowest):
  -e flag > RADP_VAGRANT_ENV > radp.env in vagrant.yaml

Examples:
  radp-vf init myproject
  radp-vf info
  radp-vf vg status
  radp-vf vg up
  radp-vf -e dev vg status
  radp-vf -e prod vg ssh node-1
  radp-vf dump-config
  radp-vf generate
USAGE
}

cmd_info() {
  local version
  version="$(get_version)"

  echo "RADP Vagrant Framework"
  echo ""
  echo "Environment:"
  echo "  Version:      ${version}"
  echo "  RADP_VF_HOME: ${RADP_VF_HOME}"
  echo ""
  echo "Environment Variables:"
  echo "  RADP_VF_PROJECT_DIR:     ${RADP_VF_PROJECT_DIR:-(not set)}"
  echo "  RADP_VAGRANT_CONFIG_DIR: ${RADP_VAGRANT_CONFIG_DIR:-(not set)}"
  echo "  RADP_VAGRANT_ENV:        ${RADP_VAGRANT_ENV:-(not set)}"

  # Try to resolve project directory
  local project_dir
  project_dir="$(resolve_project_dir 2>/dev/null)" || true

  if [[ -n "${project_dir}" ]]; then
    local config_dir="${RADP_VAGRANT_CONFIG_DIR:-${project_dir}/config}"
    local abs_config_dir
    if [[ "${config_dir}" == /* ]]; then
      abs_config_dir="${config_dir}"
    else
      abs_config_dir="${project_dir}/${config_dir}"
    fi

    echo ""
    echo "Resolved Project:"
    echo "  Project Dir:  ${project_dir}"
    echo "  Vagrantfile:  ${project_dir}/Vagrantfile"

    if [[ -d "${abs_config_dir}" ]]; then
      echo "  Config Path:  ${abs_config_dir}"

      # Show config files
      if [[ -f "${abs_config_dir}/vagrant.yaml" ]]; then
        local env_name
        env_name="$(grep -E '^\s*env:' "${abs_config_dir}/vagrant.yaml" 2>/dev/null | head -1 | sed 's/.*env:\s*//' | tr -d ' ')"
        local effective_env="${OPT_ENV:-${RADP_VAGRANT_ENV:-${env_name}}}"
        echo "  Environment:  ${effective_env:-unknown}"
        if [[ -n "${OPT_ENV}" ]]; then
          echo "                (from -e flag)"
        elif [[ -n "${RADP_VAGRANT_ENV:-}" ]]; then
          echo "                (from RADP_VAGRANT_ENV)"
        else
          echo "                (from vagrant.yaml)"
        fi
        echo ""
        echo "Config Files:"
        echo "  Base: ${abs_config_dir}/vagrant.yaml"
        if [[ -n "${effective_env}" && -f "${abs_config_dir}/vagrant-${effective_env}.yaml" ]]; then
          echo "  Env:  ${abs_config_dir}/vagrant-${effective_env}.yaml"
        elif [[ -n "${effective_env}" ]]; then
          echo "  Env:  ${abs_config_dir}/vagrant-${effective_env}.yaml (not found)"
        fi
      fi
    else
      echo "  Config Path:  ${abs_config_dir} (not found)"
    fi
  else
    echo ""
    echo "Project: (cannot be resolved)"
    echo "  Set RADP_VF_PROJECT_DIR or RADP_VAGRANT_CONFIG_DIR,"
    echo "  or run 'radp-vf init <dir>' to create a new project."
  fi
}

cmd_vg() {
  if [[ $# -eq 0 ]]; then
    echo "Usage: radp-vf vg <vagrant-command> [args...]" >&2
    echo "" >&2
    echo "Examples:" >&2
    echo "  radp-vf vg status" >&2
    echo "  radp-vf vg up" >&2
    echo "  radp-vf -e dev vg status" >&2
    return 1
  fi

  local project_dir
  project_dir="$(resolve_project_dir)" || return 1

  # Set environment override if specified
  if [[ -n "${OPT_ENV}" ]]; then
    export RADP_VAGRANT_ENV="${OPT_ENV}"
  fi

  # Change to project directory and run vagrant
  cd "${project_dir}"
  exec vagrant "$@"
}

cmd_init() {
  local target_dir="${1:-.}"
  local abs_target_dir

  mkdir -p "${target_dir}"
  abs_target_dir="$(cd "${target_dir}" && pwd)"

  if [[ -f "${target_dir}/Vagrantfile" ]]; then
    echo "Error: Vagrantfile already exists in ${abs_target_dir}" >&2
    exit 1
  fi

  echo "Initializing RADP Vagrant Framework project..."
  echo ""

  mkdir -p "${target_dir}/config"

  # Create Vagrantfile
  cat > "${target_dir}/Vagrantfile" << 'VAGRANTFILE'
# -*- mode: ruby -*-
# vi: set ft=ruby :

# RADP Vagrant Framework
# See: https://github.com/xooooooooox/radp-vagrant-framework

require_relative 'lib/radp_vagrant'

config_dir = ENV['RADP_VAGRANT_CONFIG_DIR'] || File.join(__dir__, 'config')

Vagrant.configure('2') do |config|
  RadpVagrant.configure(config, config_dir)
end
VAGRANTFILE

  # Create symlink to lib
  if [[ ! -e "${target_dir}/lib" ]]; then
    ln -s "${RADP_VF_HOME}/lib" "${target_dir}/lib"
  fi

  # Create sample vagrant.yaml
  cat > "${target_dir}/config/vagrant.yaml" << 'VAGRANT_YAML'
radp:
  env: sample
  extend:
    vagrant:
      plugins:
        - name: vagrant-hostmanager
          required: true
          options:
            enabled: true
            manage_host: true
            manage_guest: true
      config:
        common:
          # Global settings inherited by all guests
VAGRANT_YAML

  # Create sample vagrant-sample.yaml
  cat > "${target_dir}/config/vagrant-sample.yaml" << 'VAGRANT_DEV_YAML'
radp:
  extend:
    vagrant:
      config:
        clusters:
          - name: example
            common:
              box:
                name: generic/ubuntu2204
            guests:
              - id: node-1
                provider:
                  mem: 2048
                  cpus: 2
                network:
                  private-network:
                    enabled: true
                    type: dhcp
VAGRANT_DEV_YAML

  echo "Project initialized successfully!"
  echo ""
  echo "Created files:"
  echo "  ${abs_target_dir}/"
  echo "  ├── Vagrantfile"
  echo "  ├── lib -> ${RADP_VF_HOME}/lib"
  echo "  └── config/"
  echo "      ├── vagrant.yaml          # Base config (env: sample)"
  echo "      └── vagrant-sample.yaml   # Cluster definitions"
  echo ""
  echo "Configuration:"
  echo "  Framework:    ${RADP_VF_HOME}"
  echo "  Config Dir:   ${abs_target_dir}/config"
  echo "  Environment:  sample"
  echo ""
  echo "Next steps:"
  echo "  cd ${target_dir}"
  echo "  vagrant status    # View VM status"
  echo "  vagrant up        # Start VMs"
  echo ""
  echo "Edit config/vagrant.yaml to change 'env' and create your own environment file."
}

cmd_dump_config() {
  local filter="${1:-}"
  local config_dir="${RADP_VAGRANT_CONFIG_DIR:-config}"

  echo "Framework:  ${RADP_VF_HOME}" >&2
  echo "Config Dir: ${config_dir}" >&2
  if [[ -n "${filter}" ]]; then
    echo "Filter:     ${filter}" >&2
  fi
  echo "" >&2

  cd "${RADP_VF_HOME}"
  if [[ -n "${filter}" ]]; then
    ruby -r ./lib/radp_vagrant -e "RadpVagrant.dump_config('${config_dir}', '${filter}')"
  else
    ruby -r ./lib/radp_vagrant -e "RadpVagrant.dump_config('${config_dir}')"
  fi
}

cmd_generate() {
  local output="${1:-}"
  local config_dir="${RADP_VAGRANT_CONFIG_DIR:-config}"

  echo "Framework:  ${RADP_VF_HOME}" >&2
  echo "Config Dir: ${config_dir}" >&2
  if [[ -n "${output}" ]]; then
    echo "Output:     ${output}" >&2
  fi
  echo "" >&2

  cd "${RADP_VF_HOME}"
  if [[ -n "${output}" ]]; then
    ruby -r ./lib/radp_vagrant -e "RadpVagrant.generate_vagrantfile('${config_dir}', '${output}')"
    echo "Generated: ${output}" >&2
  else
    ruby -r ./lib/radp_vagrant -e "puts RadpVagrant.generate_vagrantfile('${config_dir}')"
  fi
}

cmd_version() {
  get_version
}

main() {
  # Parse global options
  while [[ $# -gt 0 ]]; do
    case "$1" in
      -e|--env)
        if [[ -z "${2:-}" ]]; then
          echo "Error: -e requires an environment name" >&2
          exit 1
        fi
        OPT_ENV="$2"
        shift 2
        ;;
      -*)
        # Check if it's a help/version flag
        case "$1" in
          -h|--help)
            usage
            exit 0
            ;;
          -v|--version)
            cmd_version
            exit 0
            ;;
          *)
            echo "Unknown option: $1" >&2
            usage >&2
            exit 1
            ;;
        esac
        ;;
      *)
        break
        ;;
    esac
  done

  local cmd="${1:-help}"
  shift || true

  case "${cmd}" in
    init)
      cmd_init "$@"
      ;;
    vg)
      cmd_vg "$@"
      ;;
    info)
      cmd_info "$@"
      ;;
    dump-config|dump_config)
      cmd_dump_config "$@"
      ;;
    generate)
      cmd_generate "$@"
      ;;
    version)
      cmd_version
      ;;
    help)
      usage
      ;;
    *)
      echo "Unknown command: ${cmd}" >&2
      usage >&2
      exit 1
      ;;
  esac
}

main "$@"
