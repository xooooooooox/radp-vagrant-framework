#!/usr/bin/env ruby
# frozen_string_literal: true

# RADP Vagrant Framework - Vagrantfile Generator
# Generates a standalone Vagrantfile from YAML configuration for inspection

require 'yaml'
require_relative 'config_loader'
require_relative 'config_merger'

module RadpVagrant
  # Generates standalone Vagrantfile from YAML configuration
  class Generator
    def initialize(config_path)
      @config_path = config_path
      @config = ConfigLoader.load(config_path)
      @indent = 0
    end

    def generate
      output = []
      output << header
      output << vagrant_configure_block
      output.join("\n")
    end

    private

    def header
      <<~HEADER
        # -*- mode: ruby -*-
        # vi: set ft=ruby :
        #
        # Generated by RADP Vagrant Framework
        # Source: #{@config_path}
        # Generated at: #{Time.now}
        #
        # This is a standalone Vagrantfile that does not require the framework.

        Vagrant.require_version '>=2.0.0'
      HEADER
    end

    def vagrant_configure_block
      vagrant_section = @config.dig('radp', 'extend', 'vagrant')
      return "# No vagrant configuration found" unless vagrant_section

      lines = []
      lines << "Vagrant.configure('2') do |config|"
      @indent = 1

      # Plugins
      generate_plugins(lines, vagrant_section['plugins'])

      # Process clusters
      common_config = vagrant_section.dig('config', 'common')
      clusters = vagrant_section.dig('config', 'clusters') || []

      clusters.each do |cluster|
        lines << ""
        lines << indent("# Cluster: #{cluster['name']}")
        generate_cluster(lines, cluster, common_config)
      end

      lines << "end"
      lines.join("\n")
    end

    def generate_plugins(lines, plugins)
      return unless plugins&.any?

      lines << ""
      lines << indent("# Plugin Configuration")
      plugins.each do |plugin|
        next unless plugin['enabled']

        plugin_name = plugin['name']
        options = plugin['options']

        case plugin_name
        when 'vagrant-hostmanager'
          generate_hostmanager_config(lines, options)
        when 'vagrant-vbguest'
          generate_vbguest_config(lines, options)
        when 'vagrant-proxyconf'
          generate_proxyconf_config(lines, options)
        end
      end
    end

    def generate_hostmanager_config(lines, options)
      return unless options

      lines << indent("config.hostmanager.enabled = #{options['enabled']}") if options.key?('enabled')
      lines << indent("config.hostmanager.manage_host = #{options['manage-host']}") if options.key?('manage-host')
      lines << indent("config.hostmanager.manage_guest = #{options['manage-guest']}") if options.key?('manage-guest')
      lines << indent("config.hostmanager.include_offline = #{options['include-offline']}") if options.key?('include-offline')
      lines << indent("config.hostmanager.ignore_private_ip = #{options['ignore-private-ip']}") if options.key?('ignore-private-ip')
    end

    def generate_vbguest_config(lines, options)
      return unless options

      lines << indent("config.vbguest.auto_update = #{options['auto-update']}") if options.key?('auto-update')
      lines << indent("config.vbguest.no_remote = #{options['no-remote']}") if options.key?('no-remote')
    end

    def generate_proxyconf_config(lines, options)
      return unless options

      lines << indent("config.proxy.http = #{options['http'].inspect}") if options.key?('http')
      lines << indent("config.proxy.https = #{options['https'].inspect}") if options.key?('https')
      lines << indent("config.proxy.no_proxy = #{options['no-proxy'].inspect}") if options.key?('no-proxy')
    end

    def generate_cluster(lines, cluster, global_common)
      cluster_name = cluster['name']
      cluster_common = cluster['common']
      guests = cluster['guests'] || []

      guests.each do |guest|
        next if guest['enabled'] == false

        merged = ConfigMerger.merge_guest_config(global_common, cluster_common, guest)
        merged['cluster-name'] = cluster_name
        merged['provider'] ||= {}
        merged['provider']['group-id'] ||= cluster_name

        generate_guest(lines, merged)
      end
    end

    def generate_guest(lines, guest)
      guest_id = guest['id']
      lines << ""
      lines << indent("# Guest: #{guest_id}")
      lines << indent("config.vm.define '#{guest_id}' do |#{safe_var(guest_id)}|")
      @indent += 1

      var = safe_var(guest_id)
      generate_box(lines, var, guest['box'])
      generate_provider(lines, var, guest['provider'])
      generate_network(lines, var, guest['network'])
      generate_synced_folders(lines, var, guest['synced-folders'])
      generate_provisions(lines, var, guest['provisions'])
      generate_triggers(lines, guest_id, guest['triggers'])

      @indent -= 1
      lines << indent("end")
    end

    def generate_box(lines, var, box)
      return unless box

      lines << indent("#{var}.vm.box = '#{box['name']}'") if box['name']
      lines << indent("#{var}.vm.box_version = '#{box['version']}'") if box['version']
      lines << indent("#{var}.vm.box_check_update = #{box['check-update']}") if box.key?('check-update')
    end

    def generate_provider(lines, var, provider)
      return unless provider

      provider_type = provider['type'] || 'virtualbox'
      lines << ""
      lines << indent("#{var}.vm.provider '#{provider_type}' do |vb|")
      @indent += 1

      lines << indent("vb.name = '#{provider['name']}'") if provider['name']
      lines << indent("vb.memory = #{provider['mem'] || 2048}")
      lines << indent("vb.cpus = #{provider['cpus'] || 2}")
      lines << indent("vb.gui = #{provider['gui'] || false}")

      if provider['group-id']
        lines << indent("vb.customize ['modifyvm', :id, '--groups', '/#{provider['group-id']}']")
      end

      @indent -= 1
      lines << indent("end")
    end

    def generate_network(lines, var, network)
      return unless network

      lines << ""
      lines << indent("# Network")
      lines << indent("#{var}.vm.hostname = '#{network['hostname']}'") if network['hostname']

      # Private network
      if network['private-network']&.dig('enabled')
        pn = network['private-network']
        if pn['type'] == 'dhcp'
          lines << indent("#{var}.vm.network 'private_network', type: 'dhcp'")
        else
          opts = []
          opts << "ip: '#{pn['ip']}'" if pn['ip']
          opts << "netmask: '#{pn['netmask']}'" if pn['netmask']
          lines << indent("#{var}.vm.network 'private_network', #{opts.join(', ')}")
        end
      end

      # Public network
      if network['public-network']&.dig('enabled')
        pn = network['public-network']
        opts = []
        if pn['type'] == 'dhcp'
          opts << "type: 'dhcp'"
        else
          opts << "ip: '#{pn['ip']}'" if pn['ip']
          opts << "netmask: '#{pn['netmask']}'" if pn['netmask']
        end
        opts << "bridge: #{pn['bridge'].inspect}" if pn['bridge']
        lines << indent("#{var}.vm.network 'public_network', #{opts.join(', ')}")
      end

      # Forwarded ports
      network['forwarded-ports']&.each do |port|
        next unless port['enabled']

        opts = ["guest: #{port['guest']}", "host: #{port['host']}"]
        opts << "protocol: '#{port['protocol']}'" if port['protocol']
        lines << indent("#{var}.vm.network 'forwarded_port', #{opts.join(', ')}")
      end

      # Hostmanager
      if network['hostmanager']&.dig('enabled')
        hm = network['hostmanager']
        lines << indent("#{var}.hostmanager.aliases = #{hm['aliases'].inspect}") if hm['aliases']
      end
    end

    def generate_synced_folders(lines, var, folders)
      return unless folders&.any?

      lines << ""
      lines << indent("# Synced Folders")
      folders.each do |folder|
        next unless folder['enabled']

        host = folder['host']
        guest = folder['guest']
        folder_type = folder['type'] || 'basic'

        opts = ["create: #{folder['create'] || false}"]

        case folder_type
        when 'basic'
          opts << "owner: '#{folder['owner']}'" if folder['owner']
          opts << "group: '#{folder['group']}'" if folder['group']
          opts << "mount_options: #{folder['mount-options'].inspect}" if folder['mount-options']
        when 'nfs'
          opts << "type: 'nfs'"
          opts << "nfs_version: #{folder['nfs-version']}" if folder['nfs-version']
        when 'rsync'
          opts << "type: 'rsync'"
          opts << "rsync__exclude: #{folder['rsync-exclude'].inspect}" if folder['rsync-exclude']
        when 'smb'
          opts << "type: 'smb'"
          opts << "smb_host: '#{folder['smb-host']}'" if folder['smb-host']
          opts << "smb_username: '#{folder['smb-username']}'" if folder['smb-username']
          opts << "smb_password: '#{folder['smb-password']}'" if folder['smb-password']
        end

        lines << indent("#{var}.vm.synced_folder '#{host}', '#{guest}', #{opts.join(', ')}")
      end
    end

    def generate_provisions(lines, var, provisions)
      return unless provisions&.any?

      lines << ""
      lines << indent("# Provisions")
      provisions.each do |provision|
        next unless provision['enabled']

        provision_type = provision['type'] || 'shell'
        name = provision['name']

        case provision_type
        when 'shell'
          generate_shell_provision(lines, var, name, provision)
        when 'file'
          generate_file_provision(lines, var, name, provision)
        end
      end
    end

    def generate_shell_provision(lines, var, name, provision)
      if provision['inline']
        lines << indent("#{var}.vm.provision 'shell', name: '#{name}', inline: <<-SHELL")
        provision['inline'].each_line do |line|
          lines << "  #{line.rstrip}"
        end
        lines << indent("SHELL")
      elsif provision['path']
        opts = ["name: '#{name}'", "path: '#{provision['path']}'"]
        opts << "privileged: #{provision['privileged']}" if provision.key?('privileged')
        opts << "run: '#{provision['freq']}'" if provision['freq']
        opts << "args: '#{provision['args']}'" if provision['args']
        lines << indent("#{var}.vm.provision 'shell', #{opts.join(', ')}")
      end
    end

    def generate_file_provision(lines, var, name, provision)
      opts = ["name: '#{name}'"]
      opts << "source: '#{provision['source']}'"
      opts << "destination: '#{provision['destination']}'"
      lines << indent("#{var}.vm.provision 'file', #{opts.join(', ')}")
    end

    def generate_triggers(lines, guest_id, triggers)
      return unless triggers&.any?

      lines << ""
      lines << indent("# Triggers")
      triggers.each do |trigger|
        next unless trigger['enabled']

        cycle = trigger['cycle'] || 'before'
        actions = trigger['action'] || [:up]
        action_str = actions.map { |a| a.to_s.delete_prefix(':').to_sym.inspect }.join(', ')

        lines << indent("config.trigger.#{cycle} #{action_str} do |t|")
        @indent += 1

        lines << indent("t.name = '#{trigger['name']}'") if trigger['name']
        lines << indent("t.info = '#{trigger['desc'] || trigger['info']}'") if trigger['desc'] || trigger['info']
        lines << indent("t.only_on = '#{guest_id}'")

        if trigger['run']
          if trigger['run']['inline']
            # Escape the inline script for Ruby string
            escaped = trigger['run']['inline'].gsub("'", "\\\\'").gsub("\n", "\\n")
            lines << indent("t.run = { inline: '#{escaped}' }")
          elsif trigger['run']['path']
            lines << indent("t.run = { path: '#{trigger['run']['path']}' }")
          end
        end

        @indent -= 1
        lines << indent("end")
      end
    end

    def indent(str)
      '  ' * @indent + str
    end

    def safe_var(name)
      name.gsub(/[^a-zA-Z0-9_]/, '_')
    end
  end
end

# CLI execution
if __FILE__ == $PROGRAM_NAME
  config_path = ARGV[0] || File.join(File.dirname(__FILE__), '..', '..', 'config', 'vagrant.yaml')

  unless File.exist?(config_path)
    warn "Error: Configuration file not found: #{config_path}"
    warn "Usage: ruby #{$PROGRAM_NAME} [config_path]"
    exit 1
  end

  generator = RadpVagrant::Generator.new(config_path)
  puts generator.generate
end
